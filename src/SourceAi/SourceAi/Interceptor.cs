using System;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace SourceAi;

[Generator]
public class AiMethodGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => node is InvocationExpressionSyntax,
                transform: GetInterceptableCallOrNull)
            .Where(m => m is not null);
        
        var groupedCalls = methodCalls.Collect().Select((calls, _) => 
            calls.GroupBy(c => c!.MethodUniqueId));
        
        var configProvider = context.AnalyzerConfigOptionsProvider;
        var combined = groupedCalls.Combine(configProvider);
        
        context.RegisterSourceOutput(combined, Execute);
    }

    private static CallInfo? GetInterceptableCallOrNull(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var symbol = context.SemanticModel.GetSymbolInfo(invocation, ct).Symbol as IMethodSymbol;

        if (symbol is null || 
            !symbol.IsStatic || 
            !symbol.IsExtern || 
            !symbol.GetAttributes().Any(a => a.AttributeClass?.Name == "AiAttribute"))
        {
            return null;
        }
        
        var location = invocation.GetLocation();
        var lineSpan = location.GetLineSpan();

        return new CallInfo(
            MethodUniqueId: symbol.ToDisplayString(),
            MethodName: symbol.Name,
            ReturnType: symbol.ReturnType.ToDisplayString(),
            Parameters: symbol.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}").ToList(),
            ParameterNames: symbol.Parameters.Select(p => p.Name).ToList(),
            FilePath: lineSpan.Path,
            Line: lineSpan.StartLinePosition.Line + 1,
            Character: lineSpan.StartLinePosition.Character + 1,
            Prompt: symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "AiAttribute")
                          ?.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? ""
        );
    }

    private void Execute(
        SourceProductionContext context, 
        (IEnumerable<IGrouping<string, CallInfo?>> Groups, AnalyzerConfigOptionsProvider Config) input)
    {
        var (groups, configProvider) = input;
        
        configProvider.GlobalOptions.TryGetValue("build_property.SourceAiApiKey", out var apiKey);
        configProvider.GlobalOptions.TryGetValue("build_property.SourceAiCachePath", out var cachePath);
        configProvider.GlobalOptions.TryGetValue("build_property.IntermediateOutputPath", out var objPath);
        
        apiKey ??= Environment.GetEnvironmentVariable("SOURCEAI_API_KEY");
        
        cachePath ??= Path.Combine(objPath ?? "obj", "SourceAi");
        _logPath = Path.Combine(cachePath, "sourceai.log");

        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace Ai.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    file static class AiInterceptors");
        sb.AppendLine("    {");

        foreach (var group in groups)
        {
            var signature = group.First()!;
            
            string signatureHash = ComputeSignatureHash(signature);
            string generatedBody;

            string? cachedBody = TryLoadFromCache(cachePath, signatureHash);
            if (cachedBody != null)
            {
                Log($"Cache HIT for {signature.MethodName} (hash: {signatureHash})");
                generatedBody = cachedBody;
            }
            else
            {
                Log($"Cache MISS for {signature.MethodName} (hash: {signatureHash})");
                generatedBody = GenerateWithAi(apiKey, signature);
                
                SaveToCache(cachePath, signatureHash, generatedBody);
            }

            foreach (var callSite in group)
            {
                sb.AppendLine($@"        [InterceptsLocation(@""{callSite!.FilePath}"", {callSite.Line}, {callSite.Character})]");
            }
            
            string paramsString = string.Join(", ", signature.Parameters);
            sb.AppendLine($"        public static {signature.ReturnType} Intercept_{signature.MethodName}({paramsString})");
            sb.AppendLine("        {");
            sb.AppendLine($"            {generatedBody}");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("AiInterceptors.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string ComputeSignatureHash(CallInfo signature)
    {
        var signatureData = $"{signature.MethodName}|{signature.ReturnType}|{string.Join(",", signature.Parameters)}|{signature.Prompt}";
        using var sha256 = SHA256.Create();
        var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(signatureData));
        return BitConverter.ToString(hashBytes).Replace("-", "").Substring(0, 16); // First 16 chars is enough
    }
    
    private static string? TryLoadFromCache(string cachePath, string signatureHash)
    {
        try
        {
            var cacheFile = Path.Combine(cachePath, $"{signatureHash}.cache");
            if (File.Exists(cacheFile))
            {
                return File.ReadAllText(cacheFile);
            }
        }
        catch
        {
            // Cache miss or read error
        }
        return null;
    }
    
    private static void SaveToCache(string cachePath, string signatureHash, string body)
    {
        try
        {
            Directory.CreateDirectory(cachePath);
            var cacheFile = Path.Combine(cachePath, $"{signatureHash}.cache");
            File.WriteAllText(cacheFile, body);
        }
        catch
        {
            // Cache write failed
        }
    }
    
    private static string GenerateWithAi(string? apiKey, CallInfo signature)
    {
        Log($"=== GenerateWithAi called ===");
        Log($"Method: {signature.MethodName}");
        Log($"API Key present: {!string.IsNullOrEmpty(apiKey)}");
        Log($"API Key prefix: {(apiKey?.Length > 10 ? apiKey.Substring(0, 10) + "..." : "N/A")}");
        
        if (string.IsNullOrEmpty(apiKey))
        {
            Log("No API key - using fake implementation");
            return FakeAiLlm(signature.MethodName, signature.ReturnType, signature.ParameterNames);
        }

        try
        {
            return CallOpenAi(apiKey!, signature);
        }
        catch (Exception ex)
        {
            Log($"Exception: {ex}");
            return $"throw new System.Exception(\"AI generation failed: {EscapeForString(ex.Message)}\");";
        }
    }

    private static readonly HttpClient HttpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(60) };
    private static string? _logPath;

    private static void Log(string message)
    {
        var logPath = "log.txt";
        try
        {
            File.AppendAllText(logPath, $"[{DateTime.Now:HH:mm:ss}] {message}\n");
        }
        catch { }
    }
    
    private static string CallOpenAi(string apiKey, CallInfo signature)
    {
        string methodSignature = $"{signature.ReturnType} {signature.MethodName}({string.Join(", ", signature.Parameters)})";
        string systemPrompt = @"You are a C# code generator. Your task is to implement method bodies based on the method signature.

RULES:
1. Generate ONLY the method body - the code that goes inside the braces { }
2. Do NOT include the method signature, braces, access modifiers, or markdown
3. The code must be valid C# that compiles
4. Use fully qualified type names (e.g., System.Console instead of Console)
5. Infer the intended behavior from the method name and parameters
6. Be concise and efficient";

        string userPrompt;
        if (!string.IsNullOrWhiteSpace(signature.Prompt))
        {
            userPrompt = $@"Implement this C# method:

```csharp
{methodSignature}
```

Description: {signature.Prompt}

Return ONLY the code that goes inside the method body.";
        }
        else
        {
            userPrompt = $@"Implement this C# method based on its name and signature:

```csharp
{methodSignature}
```

Infer what the method should do from its name and parameters. For example:
- Add(int a, int b) should return a + b
- GetFullName(string first, string last) should concatenate names
- IsEven(int n) should check if n is even

Return ONLY the code that goes inside the method body.";
        }
        
        string requestJson = BuildOpenAiRequest(systemPrompt, userPrompt);

        Log("=== OpenAI Request ===");
        Log($"Method: {signature.MethodName}");
        Log($"Signature: {methodSignature}");
        Log($"Prompt: '{signature.Prompt}'");
        Log($"User prompt:\n{userPrompt}");
        Log($"Request JSON:\n{requestJson}");

        using var request = new HttpRequestMessage(HttpMethod.Post, "https://api.openai.com/v1/chat/completions");
        request.Headers.Add("Authorization", $"Bearer {apiKey}");
        request.Content = new StringContent(requestJson, Encoding.UTF8, "application/json");
        
        var response = HttpClient.SendAsync(request).GetAwaiter().GetResult();
        var responseBody = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();

        Log($"=== OpenAI Response ===");
        Log($"Status: {response.StatusCode}");
        Log($"Body:\n{responseBody}");

        if (!response.IsSuccessStatusCode)
        {
            throw new Exception($"OpenAI API error: {response.StatusCode} - {responseBody}");
        }
        
        string generatedCode = ParseOpenAiResponse(responseBody);
        Log($"Parsed code: {generatedCode}");
        
        string? validationError = ValidateCodeCompiles(generatedCode, signature);
        if (validationError != null)
        {
            Log($"Validation error: {validationError}");
            generatedCode = RetryWithFeedback(apiKey, signature, generatedCode, validationError);
            Log($"Retry result: {generatedCode}");
        }

        return generatedCode;
    }

    private static string BuildOpenAiRequest(string systemPrompt, string userPrompt)
    {
        string escapedSystem = EscapeForJson(systemPrompt);
        string escapedUser = EscapeForJson(userPrompt);
        
        return $@"{{
  ""model"": ""gpt-4o-mini"",
  ""messages"": [
    {{""role"": ""system"", ""content"": ""{escapedSystem}""}},
    {{""role"": ""user"", ""content"": ""{escapedUser}""}}
  ],
  ""response_format"": {{
    ""type"": ""json_schema"",
    ""json_schema"": {{
      ""name"": ""code_response"",
      ""strict"": true,
      ""schema"": {{
        ""type"": ""object"",
        ""properties"": {{
          ""code"": {{""type"": ""string"", ""description"": ""The C# method body code""}}
        }},
        ""required"": [""code""],
        ""additionalProperties"": false
      }}
    }}
  }}
}}";
    }

    private static string ParseOpenAiResponse(string responseJson)
    {
        Log($"=== Parsing Response ===");
        Log($"Raw response length: {responseJson.Length}");
        Log($"Raw response: {responseJson}");

        var contentMatch = Regex.Match(responseJson, @"""content""\s*:\s*""((?:[^""\\]|\\.)*)""", RegexOptions.Singleline);
        string content;
        
        if (contentMatch.Success)
        {
            content = UnescapeJson(contentMatch.Groups[1].Value);
            Log($"Content after unescape: {content}");
        }
        else
        {
            var contentObjMatch = Regex.Match(responseJson, @"""content""\s*:\s*(\{.*?\})", RegexOptions.Singleline);
            if (contentObjMatch.Success)
            {
                content = contentObjMatch.Groups[1].Value;
                Log($"Content (object): {content}");
            }
            else
            {
                throw new Exception($"Failed to parse OpenAI response: content field not found. Response: {responseJson}");
            }
        }
        
        var codeMatch = Regex.Match(content, @"""code""\s*:\s*""((?:[^""\\]|\\.)*)""", RegexOptions.Singleline);
        if (!codeMatch.Success)
        {
            throw new Exception($"Failed to parse structured output: code field not found. Content: {content}");
        }

        var result = UnescapeJson(codeMatch.Groups[1].Value);
        Log($"Extracted code: {result}");
        return result;
    }

    private static string RetryWithFeedback(string apiKey, CallInfo signature, string previousCode, string error)
    {
        string methodSignature = $"{signature.ReturnType} {signature.MethodName}({string.Join(", ", signature.Parameters)})";

        string systemPrompt = @"You are a C# code generator. Your task is to fix compilation errors in method bodies.

RULES:
1. Generate ONLY the method body - the code that goes inside the braces { }
2. Do NOT include the method signature, braces, access modifiers, or markdown
3. The code must be valid C# that compiles
4. Use fully qualified type names (e.g., System.Console instead of Console)";

        string descriptionPart = string.IsNullOrWhiteSpace(signature.Prompt) 
            ? "" 
            : $"\nDescription: {signature.Prompt}";

        string userPrompt = $@"Your previous code had a compilation error. Please fix it.

Method signature:
```csharp
{methodSignature}
```{descriptionPart}

Your previous code:
```csharp
{previousCode}
```

Compilation error: {error}

Return ONLY the fixed code that goes inside the method body.";

        string requestJson = BuildOpenAiRequest(systemPrompt, userPrompt);

        using var request = new HttpRequestMessage(HttpMethod.Post, "https://api.openai.com/v1/chat/completions");
        request.Headers.Add("Authorization", $"Bearer {apiKey}");
        request.Content = new StringContent(requestJson, Encoding.UTF8, "application/json");

        var response = HttpClient.SendAsync(request).GetAwaiter().GetResult();
        var responseBody = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();

        if (!response.IsSuccessStatusCode)
        {
            return previousCode;
        }

        return ParseOpenAiResponse(responseBody);
    }
    
    private static string? ValidateCodeCompiles(string code, CallInfo signature)
    {
        string paramsString = string.Join(", ", signature.Parameters);
        string testCode = $@"
using System;
using System.Collections.Generic;
using System.Linq;

public static class TestClass
{{
    public static {signature.ReturnType} TestMethod({paramsString})
    {{
        {code}
    }}
}}";

        var syntaxTree = CSharpSyntaxTree.ParseText(testCode);
        var diagnostics = syntaxTree.GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();

        if (diagnostics.Count == 0)
        {
            return null;
        }
        
        return string.Join("; ", diagnostics.Select(d => d.GetMessage()));
    }

    private static string EscapeForJson(string s)
    {
        return s
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }

    private static string UnescapeJson(string s)
    {
        return s
            .Replace("\\n", "\n")
            .Replace("\\r", "\r")
            .Replace("\\t", "\t")
            .Replace("\\\"", "\"")
            .Replace("\\\\", "\\");
    }

    private static string EscapeForString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
    
    private static string FakeAiLlm(string name, string returnType, List<string> paramNames)
    {
        return "throw new System.NotImplementedException(\"AI not configured\");";
    }

    // Helper Record
    record CallInfo(string MethodUniqueId, string MethodName, string ReturnType, List<string> Parameters, List<string> ParameterNames, string FilePath, int Line, int Character, string Prompt);
}